[{"id":"454b855f-4c5e-598d-8eff-91371a596d30","fields":{"slug":"/sum-of-two-number/"},"excerpt":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:\n给定 nums = [2, 7, 11, 1…","frontmatter":{"date":"2018-11-28T22:40:32.169Z","description":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。","tags":["算法","leetCode"],"title":"两数之和"},"rawMarkdownBody":"\n# 两数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n## 答案一：\n\n```javascript\nfunction twoSum(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[j] == target - nums[i]) {\n        return [i, j]\n      }\n    }\n  }\n  throw new error(\"No two sum solution\")\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(n^2)， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)\n\n- 空间复杂度：O(1)\n\n## 答案二：\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n\nvar twoSum = function (nums, target) {\n  let obj = {}\n  let arr = []\n  for (let i = 0; i < nums.length; i++) {\n    let element = target - nums[i]\n    if (nums[i] in obj) {\n      arr.push(obj[nums[i]])\n      arr.push(i)\n      return arr\n    } else {\n      obj[element] = i\n    }\n  }\n}\n```\n\n### 复杂度分析：\n\n* 时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。\n\n* 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n"},{"id":"6d7bf47b-49c1-5332-b75c-d92b76c06b9f","fields":{"slug":"/react-diff/"},"excerpt":"当你使用 React，在单一时间点你可以考虑 render()函数作为创建 React 元素的树。在下一次状态或属性更新，render()函数将返回一个不同的 React 元素的树。React 需要算出如何高效更新 UI…","frontmatter":{"date":"2018-12-06T23:46:37.121Z","description":"","tags":null,"title":"React Diff 算法原理"},"rawMarkdownBody":"\n当你使用 React，在单一时间点你可以考虑 render()函数作为创建 React 元素的树。在下一次状态或属性更新，render()函数将返回一个不同的 React 元素的树。React 需要算出如何高效更新 UI 以匹配最新的树。\n\n有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为 n，最先进的算法 的时间复杂度为 O(n3) 。\n\n若我们在 React 中使用，展示 1000 个元素则需要进行 10 亿次的比较。这操作太过昂贵，相反，React 基于两点假设，实现了一个启发的 O(n)算法：\n\n两个不同类型的元素将产生不同的树。\n通过渲染器附带 key 属性，开发者可以示意哪些子元素可能是稳定的。\n实践中，上述假设适用于大部分应用场景。\n\n对比算法\n当对比两棵树时，React 首先比较两个根节点。根节点的 type 不同，其行为也不同。\n\n不同类型的元素\n每当根元素有不同类型，React 将卸载旧树并重新构建新树。从`<a>`到`<img>`或从`<Article>`到`<Comment>`，或从`<Button>` 到 `<div>`，任何的调整都会导致全部重建。\n\n当树被卸载，旧的 DOM 节点将被销毁。组件实例会调用 componentWillUnmount()。当构建一棵新树，新的 DOM 节点被插入到 DOM 中。组件实例将依次调用 componentWillMount()和 componentDidMount()。任何与旧树有关的状态都将丢弃。\n\n这个根节点下所有的组件都将会被卸载，同时他们的状态将被销毁。 例如，以下节点对比之后：\n\n```javascript\n<div>\n  <Counter />\n</div>\n\n<span>\n  <Counter />\n</span>\n```\n\n这将会销毁旧的 Counter 并重装新的 Counter。\n\n相同类型的 DOM 元素\n当比较两个相同类型的 React DOM 元素时，React 则会观察二者的属性，保持相同的底层 DOM 节点，并仅更新变化的属性。例如：\n\n```javascript\n<div className=\"before\" title=\"stuff\" />\n\n<div className=\"after\" title=\"stuff\" />\n```\n\n通过比较两个元素，React 知道仅更改底层 DOM 元素的 className。\n\n当更新 style 时，React 同样知道仅更新变更的属性。例如：\n\n```javascript\n<div style={{color: 'red', fontWeight: 'bold'}} />\n\n<div style={{color: 'green', fontWeight: 'bold'}} />\n```\n\n当在调整两个元素时，React 知道仅改变 color 样式而不是 fontWeight。\n\n在处理完 DOM 元素后，React 递归其子元素。\n\n相同类型的组件元素\n当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React 通过更新底层组件实例的 props 来产生新元素，并在底层实例上依次调用 componentWillReceiveProps() 和 componentWillUpdate() 方法。\n\n接下来，render()方法被调用，同时对比算法会递归处理之前的结果和新的结果。\n\n递归子节点\n默认时。当递归 DOM 节点的子节点，React 仅在同一时间点递归两个子节点列表，并在有不同时产生一个变更。\n\n例如，当在子节点末尾增加一个元素，两棵树的转换效果很好：\n\n```javascript\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n\n<ul>\n  <li>first</li>\n  <li>second</li>\n  <li>third</li>\n</ul>\n```\n\nReact 将会匹配两棵树的`<li>first</li>`，并匹配两棵树的`<li>second</li>` 节点，并插入`<li>third</li>`节点树。\n\n若原生实现，在开始插入元素会使得性能更棘手。例如，两棵树的转换效果则比较糟糕：\n\n```\n<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n```\n\nReact 会调整每个子节点，而非意识到可以完整保留`<li>Duke</li>` 和 `<li>Villanova</li>`子树。低效成了一个问题。\n\nKeys\n为解决该问题，React 支持了一个 key 属性。当子节点有 key 时，React 使用 key 来匹配原本树的子节点和新树的子节点。例如，增加一个 key 在之前效率不高的样例中能让树的转换变得高效：\n\n```javascript\n<ul>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n\n<ul>\n  <li key=\"2014\">Connecticut</li>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n```\n\n现在 React 知道带有'2014'的 key 的元素是新的，并仅移动带有'2015'和'2016'的 key 的元素。\n\n实践中，发现 key 通常不难。你将展示的元素可能已经带有一个唯一的 ID，因此 key 可以来自于你的数据中：\n\n```javascript\n<li key={item.id}>{item.name}</li>\n```\n\n当这已不再是问题，你可以给你的数据增加一个新的 ID 属性，或根据数据的某些内容创建一个哈希值来作为 key。key 必须在其兄弟节点中是唯一的，而非全局唯一。\n\n万不得已，你可以传递他们在数组中的索引作为 key。若元素没有重排，该方法效果不错，但重排会使得其变慢。\n\n当索引用作 key 时，组件状态在重新排序时也会有问题。组件实例基于 key 进行更新和重用。如果 key 是索引，则 item 的顺序变化会改变 key 值。这将导致非受控组件的状态可能会以意想不到的方式混淆和更新。\n\n这里是在 CodePen 上使用索引作为键可能导致的问题的一个例子，这里是同一个例子的更新版本，展示了如何不使用索引作为键将解决这些 reordering, sorting, 和 prepending 的问题。\n\n权衡\n牢记协调算法的实现细节非常重要。React 可能会在每次操作时渲染整个应用；而结果仍是相同的。为保证大多数场景效率能更快，我们通常提炼启发式的算法。\n\n在目前实现中，可以表明一个事实，即子树在其兄弟节点中移动，但你无法告知其移动到哪。该算法会重渲整个子树。\n\n由于 React 依赖于该启发式算法，若其背后的假设没得到满足，则其性能将会受到影响：\n\n算法无法尝试匹配不同组件类型的子元素。若你发现两个输出非常相似的组件类型交替出现，你可能希望使其成为相同类型。实践中，我们并非发现这是一个问题。\n\nKeys 应该是稳定的，可预测的，且唯一的。不稳定的 key（类似由 Math.random()生成的）将使得大量组件实例和 DOM 节点进行不必要的重建，使得性能下降并丢失子组件的状态。\n"},{"id":"7074a15b-dab2-58ae-a922-d689d212e743","fields":{"slug":"/single-thread/"},"excerpt":"单线程模型 单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript…","frontmatter":{"date":"2018-12-17T22:12:03.284Z","description":"","tags":null,"title":"定时器运行机制"},"rawMarkdownBody":"\n# 单线程模型\n\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\n\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\n\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。\n\n如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。\n\n单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。\n\n为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。\n\n# 同步任务和异步任务\n\n程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。\n\n同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。\n\n异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有”堵塞“效应。\n\n举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。\n\n# 任务队列和事件循环\n\nJavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）\n\n首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。\n\n异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。\n\nJavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。\n\n# 定时器运行机制\n\nJavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由`setTimeout()`和`setInterval()`这两个函数来完成。它们向任务队列添加定时任务。\nsetTimeout 和 setInterval 的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。\n\n这意味着，setTimeout 和 setInterval 指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout 和 setInterval 指定的任务，一定会按照预定时间执行。\n\nsetTimeout 的作用是将代码推迟到指定时间执行，如果指定时间为 0，即`setTimeout(f, 0)`，那么会立刻执行吗？\n\n答案是不会。因为上面说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行 setTimeout 指定的回调函数 f。也就是说，`setTimeout(f, 0)`会在下一轮事件循环一开始就执行。\n\n```javascript\nsetTimeout(function () {\n  console.log(1)\n}, 0)\nconsole.log(2)\n// 2\n// 1\n```\n\n上面代码先输出 2，再输出 1。因为 2 是同步任务，在本轮事件循环执行，而 1 是下一轮事件循环执行。\n\n总之，`setTimeout(f, 0)`这种写法的目的是，尽可能早地执行 f，但是并不能保证立刻就执行 f。\n\n实际上，`setTimeout(f, 0)`不会真的在 0 毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到 4 毫秒之后运行。如果电脑正在使用电池供电，会等到 16 毫秒之后运行；如果网页不在当前 Tab 页，会推迟到 1000 毫秒（1 秒）之后运行。这样是为了节省系统资源。\n"},{"id":"c307b6a7-c443-5454-a3c9-c052f63e3b17","fields":{"slug":"/learn-vue/"},"excerpt":"变化侦测 首先，我们定义一个数据对象 car： 接下来，我们使用 Object.defineProperty()改写上面的例子： 通过 Object.defineProperty()方法给 car 定义了一个 price 属性，并把这个属性的读和写分别使用 get()和 set…","frontmatter":{"date":"2020-04-13T14:46:37.121Z","description":"","tags":["vue"],"title":"vue源码学习--变化侦测"},"rawMarkdownBody":"\n## 变化侦测\n\n首先，我们定义一个数据对象 car：\n\n```javascript\nlet car = {\n  brand: \"BMW\",\n  price: 3000,\n}\n```\n\n接下来，我们使用 Object.defineProperty()改写上面的例子：\n\n```javascript\nlet car = {}\nlet val = 3000\nObject.defineProperty(car, \"price\", {\n  enumerable: true,\n  configurable: true,\n  get() {\n    console.log(\"price属性被读取了\")\n    return val\n  },\n  set(newVal) {\n    console.log(\"price属性被修改了\")\n    val = newVal\n  },\n})\n```\n\n通过 Object.defineProperty()方法给 car 定义了一个 price 属性，并把这个属性的读和写分别使用 get()和 set()进行拦截，每当该属性进行读或写操作的时候就会触发 get()和 set()。\n\n### observer 类\n\n```javascript\n// 源码位置：src/core/observer/index.js\n\n/**\n * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象\n */\nexport class Observer {\n  constructor(value) {\n    this.value = value\n    // 给value新增一个__ob__属性，值为该value的Observer实例\n    // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作\n    def(value, \"__ob__\", this)\n    if (Array.isArray(value)) {\n      // 当value为数组时的逻辑\n      // ...\n    } else {\n      this.walk(value)\n    }\n  }\n\n  walk(obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n}\n/**\n * 使一个对象转化成可观测对象\n * @param { Object } obj 对象\n * @param { String } key 对象的key\n * @param { Any } val 对象的某个key的值\n */\nfunction defineReactive(obj, key, val) {\n  // 如果只传了obj和key，那么val = obj[key]\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if (typeof val === \"object\") {\n    new Observer(val)\n  }\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get() {\n      console.log(`${key}属性被读取了`)\n      return val\n    },\n    set(newVal) {\n      if (val === newVal) {\n        return\n      }\n      console.log(`${key}属性被修改了`)\n      val = newVal\n    },\n  })\n}\n```\n\nobserver 类，它用来将一个正常的 object 转换成可观测的 object，并且给 value 新增一个**ob**属性，值为该 value 的 Observer 实例。这个操作相当于为 value 打上标记，表示它已经被转化成响应式了，避免重复操作。\n然后判断数据的类型，只有 object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中当传入的属性值还是一个 object 时使用 new observer（val）来递归子属性，这样我们就可以把 obj 中的所有属性（包括子属性）都转换成 getter/seter 的形式来侦测变化。 也就是说，只要我们将一个 object 传到 observer 中，那么这个 object 就会变成可观测的、响应式的 object。\n\n## 依赖收集\n\n谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发 getter 属性，那么我们就可以在 getter 中收集这个依赖。同样，当这个数据变化时会触发 setter 属性，那么我们就可以在 setter 中通知依赖更新。\n\n总结一句话就是：在 getter 中收集依赖，在 setter 中通知依赖更新。\n\n### dep 类\n\n```javascript\n// 源码位置：src/core/observer/dep.js\nexport default class Dep {\n  constructor() {\n    this.subs = []\n  }\n\n  addSub(sub) {\n    this.subs.push(sub)\n  }\n  // 删除一个依赖\n  removeSub(sub) {\n    remove(this.subs, sub)\n  }\n  // 添加一个依赖\n  depend() {\n    if (window.target) {\n      this.addSub(window.target)\n    }\n  }\n  // 通知所有依赖更新\n  notify() {\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n/**\n * Remove an item from an array\n */\nexport function remove(arr, item) {\n  if (arr.length) {\n    const index = arr.indexOf(item)\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n```\n\n在上面的依赖管理器 Dep 类中，我们先初始化了一个 subs 数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。\n\n有了依赖管理器后，我们就可以在 getter 中收集依赖，在 setter 中通知依赖更新了，代码如下\n\n```javascript\nfunction defineReactive(obj, key, val) {\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if (typeof val === \"object\") {\n    new Observer(val)\n  }\n  const dep = new Dep() //实例化一个依赖管理器，生成一个依赖管理数组dep\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get() {\n      dep.depend() // 在getter中收集依赖\n      return val\n    },\n    set(newVal) {\n      if (val === newVal) {\n        return\n      }\n      val = newVal\n      dep.notify() // 在setter中通知依赖更新\n    },\n  })\n}\n```\n\n在上述代码中，我们在 getter 中调用了 dep.depend()方法收集依赖，在 setter 中调用 dep.notify()方法通知所有依赖更新。\n\n## 依赖到底是谁\n\n其实在 Vue 中还实现了一个叫做 Watcher 的类，而 Watcher 类的实例就是我们上面所说的那个\"谁\"。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个 Watcher 实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的 Watch 实例，由 Watcher 实例去通知真正的视图。\n\n### watcher 类\n\n```javascript\nexport default class Watcher {\n  constructor(vm, expOrFn, cb) {\n    this.vm = vm\n    this.cb = cb\n    this.getter = parsePath(expOrFn)\n    this.value = this.get()\n  }\n  get() {\n    window.target = this\n    const vm = this.vm\n    let value = this.getter.call(vm, vm)\n    window.target = undefined\n    return value\n  }\n  update() {\n    const oldValue = this.value\n    this.value = this.get()\n    this.cb.call(this.vm, this.value, oldValue)\n  }\n}\n\n/**\n * Parse simple path.\n * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来\n * 例如：\n * data = {a:{b:{c:2}}}\n * parsePath('a.b.c')(data)  // 2\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath(path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  const segments = path.split(\".\")\n  return function (obj) {\n    for (let i = 0; i < segments.length; i++) {\n      if (!obj) return\n      obj = obj[segments[i]]\n    }\n    return obj\n  }\n}\n```\n\n谁用到了数据，谁就是依赖，我们就为谁创建一个 Watcher 实例，在创建 Watcher 实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个 Watcher 实例就代表这个依赖，当数据变化时，我们就通知 Watcher 实例，由 Watcher 实例再去通知真正的依赖。\n\n### Watcher 类的代码实现逻辑：\n\n1. 当实例化 Watcher 类时，会先执行其构造函数；\n2. 在构造函数中调用了 this.get()实例方法；\n3. 在 get()方法中，首先通过 window.target = this 把实例自身赋给了全局的一个唯一对象 window.target 上，然后通过 let value = this.getter.call(vm, vm)获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的 getter，上文我们说过，在 getter 里会调用 dep.depend()收集依赖，而在 dep.depend()中取到挂载 window.target 上的值并将其存入依赖数组中，在 get()方法最后将 window.target 释放掉。\n4. 而当数据变化时，会触发数据的 setter，在 setter 中调用了 dep.notify()方法，在 dep.notify()方法中，遍历所有依赖(即 watcher 实例)，执行依赖的 update()方法，也就是 Watcher 类中的 update()实例方法，在 update()方法中调用数据变化的更新回调函数，从而更新视图。\n\n## 总结\n\n总结一下就是：Watcher 先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的 getter。接着，在 getter 中就会从全局唯一的那个位置读取当前正在读取数据的 Watcher，并把这个 watcher 收集到 Dep 中去。收集好之后，当数据发生变化时，会向 Dep 中的每个 Watcher 发送通知。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。为了便于理解，从官网找到一张流程图，如下图：\n![流程图](./flow.jpg)\n"},{"id":"d521b323-da89-5f25-b6be-db70e9a28458","fields":{"slug":"/http/"},"excerpt":"HTTP 协议简介 1、HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 2、HTTP 是一个基于 TCP/IP…","frontmatter":{"date":"2020-06-01T06:53:33.508Z","description":"","tags":null,"title":"HTTP 协议"},"rawMarkdownBody":"\n## HTTP 协议简介\n\n1、HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\n2、HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n3、HTTP 是一个属于应用层的面向对象的协议。\n\n4、HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。\n\n## 主要特点\n\n1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。\n\n2、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。\n\n3、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n4、无状态：HTTP 协议是无状态协议。\n\n5、支持 B/S 及 C/S 模式。\n\n## HTTP 之 URL\n\nHTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。\nURL,全称是 UniformResourceLocator, 是一种特殊类型的 URI，包含了用于查找某个资源的足够的信息。一个完整的 url 包含以下几个部分：\n\n1. 协议部分：该 URL 的协议部分为“http：”，这代表网页使用的是 HTTP 协议。在 Internet 中可以使用多种协议，如 HTTP，FTP 等等本例中使用的是 HTTP 协议。在\"HTTP\"后面的“//”为分隔符\n\n2. 域名部分：一个 URL 中，也可以使用 IP 地址作为域名使用\n\n3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个 URL 必须的部分，如果省略端口部分，将采用默认端口\n\n4. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个 URL 必须的部分。\n\n5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。文件名部分也不是一个 URL 必须的部分，如果省略该部分，则使用默认的文件名\n\n6. 锚部分：从“#”开始到最后，都是锚部分。锚部分也不是一个 URL 必须的部分\n\n7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\n\n## HTTP 之请求消息 Request\n\n客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：\n\n请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。\nGet 请求例子：\n\n```\n    GET /562f25980001b1b106000338.jpg HTTP/1.1\n    Host    img.mukewang.com\n    User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\n    Accept    image/webp,image/*,*/*;q=0.8\n    Referer    http://www.imooc.com/\n    Accept-Encoding    gzip, deflate, sdch\n    Accept-Language    zh-CN,zh;q=0.8\n```\n\nHTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\n\nTCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0 版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。\n\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段。\n\n```\n    Connection: keep-alive\n```\n\n这个字段要求服务器不要关闭 TCP 连接，以便其他请求复用。服务器同样回应这个字段。\n客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。\n\n## HTTP 之响应消息 Response\n\n一般情况下，服务器接收并处理客户端发过来的请求后会返回一个 HTTP 的响应消息。\n\nHTTP 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n```\n    HTTP/1.0 200 OK\n    Content-Type: text/plain\n    Content-Length: 137582\n    Expires: Thu, 05 Dec 1997 16:00:00 GMT\n    Last-Modified: Wed, 5 August 1996 15:55:28 GMT\n    Server: Apache 0.84\n\n    <html>\n    <body>Hello World</body>\n    </html>\n```\n\n服务器回应的时候，必须告诉客户端，数据是什么格式，这就是 Content-Type 字段的作用。\nContent-Type 字段的值的数据类型总称为 MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。\nMIME type 还可以在尾部使用分号，添加参数\n\n```\n    Content-Type: text/html; charset=utf-8\n```\n\n客户端请求的时候，也可以使用 Accept 字段声明自己可以接受哪些数据格式。\n\n```\n    Accept: */*\n```\n\n## HTTP 之状态码\n\n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n\n- 1xx：指示信息--表示请求已接收，继续处理\n- 2xx：成功--表示请求已被成功接收、理解、接受\n- 3xx：重定向--要完成请求必须进行更进一步的操作\n- 4xx：客户端错误--请求有语法错误或请求无法实现\n- 5xx：服务器端错误--服务器未能实现合法的请求\n\n## HTTP 工作原理\n\nHTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n以下是 HTTP 请求/响应的步骤：\n\n1. 客户端连接到 Web 服务器\n   一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP 套接字连接。例如，http://www.oakcms.cn。\n\n2. 发送 HTTP 请求\n   通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。\n\n3. 服务器接受请求并返回 HTTP 响应\n   Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。\n\n4. 释放连接 TCP 连接\n   若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接;若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n\n5. 客户端浏览器解析 HTML 内容\n   客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。\n\n例如：在浏览器地址栏键入 URL，按下回车之后会经历以下流程：\n\n1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n\n2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;\n\n3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;\n\n4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n\n5. 释放 TCP 连接;\n\n6. 浏览器将该 html 文本并显示内容;\n\n## GET 和 POST 请求的区别\n\n- GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&相连，如 EditPosts.aspx?name=test1&id=123456. POST 方法是把提交的数据放在 HTTP 包的 Body 中.\n\n- GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制.\n\n- GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值。\n\n- GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.\n"},{"id":"c041156b-d7c2-5904-92a8-aef45fcf83eb","fields":{"slug":"/javascript-types/"},"excerpt":"JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。 number 用于任何类型的数字：整数或浮点数，在 ±253 范围内的整数。 bigint 用于任意长度的整数。 string…","frontmatter":{"date":"2020-06-24T13:51:33.508Z","description":"JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。","tags":null,"title":"javaScript 数据类型"},"rawMarkdownBody":"\n## JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。\n\n- number 用于任何类型的数字：整数或浮点数，在 ±253 范围内的整数。\n- bigint 用于任意长度的整数。\n- string 用于字符串：一个字符串可以包含一个或多个字符，所以没有单独的单字符类型。\n- boolean 用于 true 和 false。\n- null 用于未知的值 —— 只有一个 null 值的独立类型。\n- undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型。\n- symbol 用于唯一的标识符。\n- object 用于更复杂的数据结构。\n\n我们可以通过 typeof 运算符查看存储在变量中的数据类型。\n\n两种形式：typeof x 或者 typeof(x)。\n以字符串的形式返回类型名称，例如 \"string\"\n\n```javaScript\n    typeof undefined // \"undefined\"\n\n    typeof 0 // \"number\"\n\n    typeof 10n // \"bigint\"\n\n    typeof true // \"boolean\"\n\n    typeof \"foo\" // \"string\"\n\n    typeof Symbol(\"id\") // \"symbol\"\n\n    typeof Math // \"object\"  (1)\n\n    typeof null // \"object\"  (2)\n\n    typeof alert // \"function\"  (3)\n```\n\n最后三行可能需要额外的说明：\n\n1. Math 是一个提供数学运算的内建 object。此处仅作为一个 object 的示例。\n2. typeof null 的结果是 \"object\"。这其实是不对的。官方也承认了这是 typeof 运算符的问题，现在只是为了兼容性而保留了下来。当然，null 不是一个 object。null 有自己的类型，它是一个特殊值。再次强调，这是 JavaScript 语言的一个错误。\n3. typeof alert 的结果是 \"function\"，因为 alert 在 JavaScript 语言中是一个函数。在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待。这不是很正确的做法，但在实际编程中非常方便。\n"},{"id":"e08abafb-65ab-5efe-8845-29b18830dbe0","fields":{"slug":"/method-borrowing/"},"excerpt":"从对象中借用方法 一个 function 即便是定义在一个对象中，作为对象的一个“方法”，它也只不过是一个普通的函数而已，跟其他函数没有任何区别。在执行时仍然需要为 this 绑定一个具体的对象。 this 并不指 function 对象本身，也不是指 function…","frontmatter":{"date":"2020-08-10T01:44:05.833Z","description":"在JavaScript中，可以从其他对象借用方法来构建某些功能，而不必继承它们的所有属性和方法。就是我们从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它","tags":null,"title":"javaScript 方法借用（method borrowing）"},"rawMarkdownBody":"\n## 从对象中借用方法\n\n一个 function 即便是定义在一个对象中，作为对象的一个“方法”，它也只不过是一个普通的函数而已，跟其他函数没有任何区别。在执行时仍然需要为 this 绑定一个具体的对象。\n\n```javaScript\nvar obj = {\n    a: 1,\n    foo: function f() {\n        console.log(this.a);\n    }\n}\n\nobj.foo(); //1\n\nvar g = obj.foo;\ng();    //undefined\n\nobj.foo.call(obj); //1\n```\n\nthis 并不指 function 对象本身，也不是指 function 的作用域对象。而是在运行时绑定到特定的对象上。因此直接借用对象里的函数 foo，在非严格模式下没有明确绑定对象，this 会指向全局对象，所以输出 undefined。在严格模式下则会报错。\n\n## 使用 \"func.call\"和 \"func.apply\" 设定上下文\n\njavaScript 有一个特殊的内置函数方法 func.call(context, ...args)，它允许调用一个显式设置 this 的函数。\n语法如下：\n\n```javaScript\nfunc.call(context, arg1, arg2, ...)\n```\n\n它运行 func，提供的第一个参数作为 this，后面的作为参数（arguments）\n\n使用 func.call 的时候如果需要传递多个参数时要搭配扩展运算符\n\n```javascript\nfunc.call(this, ...arguments)\n```\n\n我们也可以使用 func.apply(this, arguments)代替，它运行 func 设置 this=context，并使用类数组对象 args 作为参数列表（arguments）。\ncall 和 apply 之间唯一的语法区别是，call 期望一个参数列表，而 apply 期望一个包含这些参数的类数组对象。\n\n因此，这两个调用几乎是等效的：\n\n```javascript\nfunc.call(context, ...args) // 使用 spread 语法将数组作为列表传递\nfunc.apply(context, args) // 与使用 call 相同\n```\n\n这里只有很小的区别：\n\n- Spread 语法 ... 允许将 可迭代对象 args 作为列表传递给 call。\n- apply 仅接受 类数组对象 args。\n  因此，当我们期望可迭代对象时，使用 call，当我们期望类数组对象时，使用 apply。\n\n对于即可迭代又是类数组的对象，例如一个真正的数组，我们使用 call 或 apply 均可，但是 apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。\n将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。\n这是它的最简形式：\n\n```\nlet wrapper = function() {\n  return func.apply(this, arguments);\n};\n```\n\n当外部代码调用这种包装器 `wrapper` 时，它与原始函数 `func` 的调用是无法区分的。\n\n## 方法借用（method borrowing）\n\n在 JavaScript 中，可以从其他对象借用方法来构建某些功能，而不必继承它们的所有属性和方法。从上面的例子我们已经知道不能直接借用对象里的方法，这样会由于 this 的问题而出现意想不到的结果，所以要借助 func.call 或者 func.apply 实现。\n\n1. 一个最常见的例子就是伪数组的转换\n\n```\n[].slice.call(arguments)\n```\n\nslice 方法内部的 this 就会被替换成 arguments，并循环遍历 arguments，复制到新数组返回，这样就得到了一个复制 arguments 类数组的数组对象.\n\n2. 使用 Object.prototype.toString 方法来揭示类型\n\n除了 `instanceof` 操作符用于检查一个对象是否属于某个特定的 class 之外，还可以借用 Object.prototype.toString 来检查变量的数据类型\n\n```\nlet obj = {};\n\nalert(obj); // [object Object]\n```\n\n一个普通对象被转化为字符串时为 [object Object],原因在于内建的 toString 方法。该方法可以被从对象中提取出来，并在任何其他值的上下文中执行。其结果取决于该值。\n\n- 对于 number 类型，结果是 [object Number]\n- 对于 boolean 类型，结果是 [object Boolean]\n- 对于 null：[object Null]\n- 对于 undefined：[object Undefined]\n- 对于数组：[object Array]\n- ……等（可自定义）\n\n```javascript\nlet s = Object.prototype.toString\n\nconsole.log(s.call([])) // [object Array]\nconsole.log(s.call(123)) // [object Number]\nconsole.log(s.call(null)) // [object Null]\nconsole.log(s.call(console.log)) // [object Function]\n```\n\n还可以使用特殊的对象属性 Symbol.toStringTag 自定义对象的 toString 方法的行为。\n\n例如：\n\n```javascript\nlet user = {\n  [Symbol.toStringTag]: \"User\",\n}\n\nconsole.log({}.toString.call(user)) // [object User]\n```\n\n## func.bind()\n\ncall apply bind 都有着改变 this 指向的功能，但与 call 和 apply 不同，bind 返回的是一个新的函数，你必须调用它才会被执行。\n\n```javascript\nconst Animal = {\n  name: \"动物\",\n  say() {\n    console.log(`大家好，我是${this.name}`)\n  },\n}\n\nconst Cat = {\n  name: \"大狸猫\",\n}\n\nAnimal.say.call(Cat)\n// 大家好，我是大狸猫\n\nAnimal.say.apply(Cat)\n// 大家好，我是大狸猫\n\nAnimal.say.bind(Cat)()\n// 大家好，我是大狸猫\n```\n\n方法 `func.bind(context, ...args)` 返回函数 func 的“绑定的（bound）变体”，它绑定了上下文 this 和第一个参数（如果给定了）。\n同样有个很常见的例子是简写`console.log()`\n\n```javascript\nlet log = console.log.bind(console)\nlog(\"123\") // 123\n```\n"},{"id":"df11174d-95aa-523a-b2a7-cea52a8af989","fields":{"slug":"/continuous-sequence/"},"excerpt":"求解连续数列 已知连续正整数数列{K}=K1,K2,K3…Ki 的各个数相加之和为 S，i=N (0<S<100000, 0<N<100000), 求此数列 K。输入描述:\n输入包含两个参数，1)连续正整数数列和 S，2)数列里数的个数 N。 输出描述: 如果有解输出数列 K…","frontmatter":{"date":"2020-08-12T05:56:22.292Z","description":"已知连续正整数数列{K}=K1,K2,K3...Ki的各个数相加之和为S","tags":["算法"],"title":"求解连续数列"},"rawMarkdownBody":"\n## 求解连续数列\n\n已知连续正整数数列{K}=K1,K2,K3...Ki 的各个数相加之和为 S，i=N (0<S<100000, 0<N<100000), 求此数列 K。输入描述:\n输入包含两个参数，1)连续正整数数列和 S，2)数列里数的个数 N。 输出描述:  \n如果有解输出数列 K，如果无解输出-1\n\n### 答案一：\n\n```javascript\nlet solution = (target, len) => {\n  let arr = new Array(len).fill(0).map((i, index) => index)\n  let sum = eval(arr.join(\"+\"))\n  if ((target - sum) % len === 0) {\n    const a = (target - sum) / len\n    return arr.map(i => i + a)\n  }\n  return -1\n}\n```\n\n#### 复杂度分析：\n\n- 时间复杂度：O(1)\n\n- 空间复杂度：O(n)\n\n### 答案二：\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n\nfunction solution(sum, n) {\n  let arr = []\n  let startNum = sum / n - (n - 1) / 2\n  if (n % 2 !== 0 && sum % n === 0) {\n    for (let i = 0; i < n; i++) {\n      arr.push(startNum)\n      startNum++\n    }\n    return arr\n  } else if ((sum % n) * 2 == n) {\n    for (let i = 0; i < n; i++) {\n      arr.push(startNum)\n      startNum++\n    }\n    return arr\n  } else {\n    return -1\n  }\n}\n```\n\n#### 复杂度分析：\n\n- 时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。\n\n- 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n"},{"id":"7504e83f-474d-5aac-95c7-7212bbb758c7","fields":{"slug":"/axios-interceptor/"},"excerpt":"在 Axios 中拦截器是非常有用的一个功能，可以让我们实现请求前对 config 参数进行调整以及响应后的数据处理。\n由于可以添加多个请求或响应拦截器，所以很明显 Axios 的拦截器内部是一个数组，通过 use 方法进行添加拦截器，通过 eject…","frontmatter":{"date":"2021-08-20","description":"在 Axios 中拦截器是非常有用的一个功能，可以让我们实现请求前对 config 参数进行调整以及响应后的数据处理","tags":["axios"],"title":"Axios 中拦截器的实现"},"rawMarkdownBody":"\n在 Axios 中拦截器是非常有用的一个功能，可以让我们实现请求前对 config 参数进行调整以及响应后的数据处理。\n由于可以添加多个请求或响应拦截器，所以很明显 Axios 的拦截器内部是一个数组，通过 use 方法进行添加拦截器，通过 eject 方法删除某个拦截器。\n\n所以先实现拦截器管理类的第一步\n\n- 存在一个内部变量维护拦截器的添加和删除\n- 通过 use 方法添加拦截器，并返回此拦截器在数组中的位置方便删除操作\n- 通过 eject 方法删除某个拦截器\n\n```javascript\nclass InterceptorManager {\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved, rejected) {\n    // 拦截器包含resolved和rejected两个函数\n    let interceptor = {\n      resolved,\n      rejected,\n    }\n    this.interceptors.push(interceptor)\n    return this.interceptors.length - 1\n  }\n\n  eject(id) {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null // 不改变数组长度，把对应拦截器设为null\n    }\n  }\n}\n```\n\n通过以上拦截器的实现，那么一个简易的 Axios 类就很简单了\n\n- 创建两个实例对应请求拦截器和响应拦截器\n- 添加一个 request 方法模拟 xhr 请求，入参为 config，返回值为 response\n\n```javascript\nclass Axios {\n  constructor() {\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager(),\n    }\n  }\n  request(config) {\n    return Promise.resolve(response)\n  }\n}\n//拦截器的使用\nconst axios = new Axios()\naxios.interceptors.request.use(config => {\n  config.header.Token = \"string\"\n  return config\n})\n\nconsole.log(axios.interceptors.request)\n// InterceptorManager {\n//   interceptors: [ { resolved: [Function (anonymous)], rejected: undefined } ]\n// }\n```\n\n这样通过调用 use 方法的调用就可以把自定义的拦截器函数推入相应的拦截器数组里，但是存进数组里的方法暂时还不能够调用，那么再对 InterceptorManager 类提供一个 forEach 的方法供外部调用，具体实现为：\n\n```javascript\nclass InterceptorManager {\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved, rejected) {\n    // 拦截器包含resolved和rejected两个函数\n    let interceptor = {\n      resolved,\n      rejected,\n    }\n    this.interceptors.push(interceptor)\n    return this.interceptors.length - 1\n  }\n\n  eject(id) {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null // 不改变数组长度，把对应拦截器设为null\n    }\n  }\n\n  forEach(fn) {\n    this.interceptors.forEach(interceptor => {\n      if (interceptor !== null) {\n        fn(interceptor)\n      }\n    })\n  }\n}\n```\n\n剩下的工作就是在 Axios 创建实例的时候把请求拦截器加在 xhr 请求之前，把响应拦截器放在获取数据之后，而且整个步骤是按顺序链式调用的。\n\n```javascript\nclass Axios {\n  constructor() {\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager(),\n    }\n  }\n  // 模拟一个xhr请求，log此时的config，返回带有response的Promise对象\n  xhr(config) {\n    console.log(config)\n    return Promise.resolve({ code: 200, data: \"test\" })\n  }\n  request(config) {\n    //创建一个新数据组按顺序存放拦截器和请求方法\n    const chain = [\n      {\n        resolved: this.xhr,\n        rejected: undefined,\n      },\n    ]\n    //请求拦截器放在请求调用之前\n    this.interceptors.request.forEach(interceptor => {\n      chain.unshift(interceptor)\n    })\n    //响应拦截器放在请求调用之后\n    this.interceptors.response.forEach(interceptor => {\n      chain.push(interceptor)\n    })\n\n    let promise = Promise.resolve(config)\n\n    while (chain.length) {\n      const { resolved, rejected } = chain.shift()\n      promise = promise.then(resolved, rejected)\n    }\n    return promise\n  }\n}\n```\n\n这样整个 Axios 的拦截器功能就实现了，通过对 chain 数组的遍历完成链式调用，而且在执行到 xhr 请求时把参数从 config 换成了 response，这样响应拦截器的参数就变成了 response。\n\n完整代码如下：\n\n```javascript\nclass InterceptorManager {\n  constructor() {\n    this.interceptors = []\n  }\n\n  use(resolved, rejected) {\n    // 拦截器包含resolved和rejected两个函数\n    let interceptor = {\n      resolved,\n      rejected,\n    }\n    this.interceptors.push(interceptor)\n    return this.interceptors.length - 1\n  }\n\n  eject(id) {\n    if (this.interceptors[id]) {\n      this.interceptors[id] = null // 不改变数组长度，把对应拦截器设为null\n    }\n  }\n\n  forEach(fn) {\n    this.interceptors.forEach(interceptor => {\n      if (interceptor !== null) {\n        fn(interceptor)\n      }\n    })\n  }\n}\n\nclass Axios {\n  constructor() {\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager(),\n    }\n  }\n  xhr(config) {\n    console.log(config)\n    return Promise.resolve({ code: 200, data: \"test\" })\n  }\n  request(config) {\n    //创建一个新数据组按顺序存放拦截器和请求方法\n    const chain = [\n      {\n        resolved: this.xhr,\n        rejected: undefined,\n      },\n    ]\n    //请求拦截器放在请求调用之前\n    this.interceptors.request.forEach(interceptor => {\n      chain.unshift(interceptor)\n    })\n    //响应拦截器放在请求调用之后\n    this.interceptors.response.forEach(interceptor => {\n      chain.push(interceptor)\n    })\n\n    let promise = Promise.resolve(config)\n\n    while (chain.length) {\n      const { resolved, rejected } = chain.shift()\n      promise = promise.then(resolved, rejected)\n    }\n    return promise\n  }\n}\n\nconst axios = new Axios()\n\n//为config的headers属性添加Token字段\naxios.interceptors.request.use(config => {\n  config.headers.Token = \"string\"\n  return config\n})\n\n//为返回值添加一个msg属性\naxios.interceptors.response.use(response => {\n  response.msg = \"success\"\n  return response\n})\n\naxios\n  .request({\n    url: \"/api\",\n    headers: {},\n  })\n  .then(res => {\n    console.log(res)\n  })\n\n// config: { url: '/api', headers: { Token: 'string' } }\n// reponse: { code: 200, data: 'test', msg: 'success' }\n```\n"},{"id":"15ee774d-7650-56bb-8bde-b6d8042d9b07","fields":{"slug":"/github-actions/"},"excerpt":"最近重新鼓捣 Gatsby Blog，认真翻看它了文档，发现用 markdown 本地文件只是其中一种数据来源方式，它还支持 CMS、数据库或者其他第三方数据。用 markdown 编写发布文章是通过处理成本地数据再利用 GraphQL 查询，然后利用 Gatsby…","frontmatter":{"date":"2021-09-10 16:52:00","description":"最近重新鼓捣 Gatsby Blog，翻看它了文档，发现了它支持多种数据来源。虽然我是采用markdown编写，处理成本地数据再利用GraphQL查询，这就利用了Gatsby提供的hooks，刚好在这里可以让我用来把数据提交到数据库。","tags":["Gatsby","github"],"title":"Github Actions的使用"},"rawMarkdownBody":"\n最近重新鼓捣 Gatsby Blog，认真翻看它了文档，发现用 markdown 本地文件只是其中一种数据来源方式，它还支持 CMS、数据库或者其他第三方数据。用 markdown 编写发布文章是通过处理成本地数据再利用 GraphQL 查询，然后利用 Gatsby 提供的 hooks 自定义 UI 组件，而我刚好也可以在这个过程里把处理好的数据完成备份。\n\n> A core feature of Gatsby is its ability to load data from anywhere -- CMSs, Markdown, other third-party systems, even spreadsheets. This allows teams to manage their content in nearly any backend they prefer.\n\n之前的数据备份是通过 GitHub webhooks 来做的，但是通过 Github Api 获取的数据有限而且麻烦。而且项目本身就要使用 Github Actions 在 push 事件触发后来构建项目并发布到 Github Pages，所以想在构建的过程中读取项目里的数据然后发送到指定的接口。\n\n具体做法通过 gatsby-source-filesystem 来处理文件数据，构建时在 gatsby-node.js 里生成所需的 json 文件，然后读取 json 发送给服务器。\n\n#### 首先第一步是读取 json 数据，输出结果为 package.outputs.content\n\n```yml\n- name: Read json file\n    id: package\n    uses: juliangruber/read-file-action@v1\n    with:\n      path: ./public/gatsby-posts.json\n```\n\n#### 其次是获取此次数据变更的内容,得到的结果为 file_changes.outputs:{files_modified,files_added,files_removed}\n\n```yml\n- name: Get commit changes\n  id: file_changes\n  uses: trilom/file-changes-action@v1.2.3\n  with:\n    githubRepo: liweili50/liweili50.github.io\n```\n\n#### 最终就是把数据发送到指定的服务器接口\n\n```yml\n- name: Make a HTTP Request\n  uses: actionsflow/axios@v1\n  with:\n    url: ${{ secrets.WEBHOOK_URL }}\n    method: POST\n    body: |\n      {\n        \"modified\":${{ steps.file_changes.outputs.files_modified }},\n        \"added\":${{ steps.file_changes.outputs.files_added}},\n        \"removed\":${{ steps.file_changes.outputs.files_removed}},\n        \"posts\":${{ steps.package.outputs.content }}\n      }\n```\n\n这样就完成了在每次提交 markdown 文件后就会把 Gatsby 生成的数据以及变更的文件内容发送到服务器，服务端就可以按需更新数据库。\n\n具体代码请移步：[https://github.com/liweili50/liweili50.github.io/blob/master/.github/workflows/main.yml](https://github.com/liweili50/liweili50.github.io/blob/master/.github/workflows/main.yml)\n"},{"id":"4ca84140-acfc-506a-a16c-095d0cb2bd40","fields":{"slug":"/wsl-setup/"},"excerpt":"WSL(适用于 Linux 的 Windows 子系统)可让开发人员直接在 Windows 上按原样运行 GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。 WSL 的安装 以管理员身份运行 powershell…","frontmatter":{"date":"2021-09-24 19:12:10","description":"","tags":["Linux","WSL"],"title":"使用LxRunOffline管理WSL"},"rawMarkdownBody":"\nWSL(适用于 Linux 的 Windows 子系统)可让开发人员直接在 Windows 上按原样运行 GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。\n\n#### WSL 的安装\n\n- 以管理员身份运行 powershell ，输入下面的代码，等待提示完成后，重启系统：\n\n```\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n```\n\n- 在 win10 商店里直接搜索 Ubuntu 即可选择版本下载安装\n- 第一次打开会初始化，等待安装完毕，然后设置好用户名和密码\n\n到这里就完成了 WSL 的安装，但这其实只是 WSL1，微软更推荐使用 WSL2，他们的区别可以参考知乎讨论：\n[从 wsl 到 wsl2 明显是退步，为什么还有人鼓吹 wsl2？](https://www.zhihu.com/question/424191615/answer/1842582111)\n\n#### 接下来就是 WSL2 的安装\n\n- 以管理员身份打开 PowerShell 并运行：\n\n```\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n- 执行以下命令将 wsl1 转为 wsl2\n\n```\nwsl --set-version Ubuntu 2\n```\n\n- 查看版本\n\n```\nwsl -l -v\n```\n\n至此 WSL2 的安装也大功告成，但是通过这种安装是装在 C 盘目录下的，随着后续的使用不可避免的会导致 C 盘越来越大，那可不可以安装到别的盘呢？答案当然是可以的，而且还支持更强大的功能！\n\n#### 使用 LxRunOffline 让 WSL 更好用\n\nLxRunOffline 可以将任何发行版的 Linux 以 WSL 形式安装到 Windows 10 中，除此之外还可以把已安装在 C 盘的 WSL 转移到指定位置，还支持可以实现 WSL 系统备份和恢复。\n\nLxRunOffline 的下载可以通过 GitHub 下载源文件直接安装，也可以通过包管理工具安装，比如我使用的是 choco：\n\n```\nchoco install lxrunofflines\n```\n\n- 安装完毕之后运行命令查看已安装的 WSL\n\n```\nLxRunOffline l\n```\n\n正常会输出已安装的 Linux 发行版的名称，比如：Ubuntu\n\n- 然后输入一下命令，比如我将 Ubuntu 转移到我的 D 盘下的 D:\\Linux\\Ubuntu 中：\n\n```\nLxRunOffline m -n Ubuntu -d D:\\Linux\\Ubuntu\n\n```\n\n- 最后查看路径看是否已经完成\n\n```\nLxRunOffline di -n Ubuntu\n\n```\n\n至此从 WSL1 的安装到转换到 WSL2，然后利用 LxRunOffline 移动到 D 盘都已完成，这就是我经历的整个折腾过程。\n\n当然 LxRunOffline 还有其他很重要的功能请访问：\n[A full-featured utility for managing Windows Subsystem for Linux](https://github.com/DDoSolitary/LxRunOffline)\n"},{"id":"5a9f7052-7b18-5bf0-8164-1030c4af62aa","fields":{"slug":"/shuffle-algorithm/"},"excerpt":"洗牌算法是我们常见的随机问题，在玩游戏、随机排序时经常会碰到。具体就是使原数组的某个数在打散后的数组中的每个位置上等概率的出现。 算法步骤为： 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值 生成一个从 0 到 n - 1 的随机数 x 输出 arr…","frontmatter":{"date":"2021-10-13 10:32:32","description":"洗牌算法是我们常见的随机问题，在玩游戏、随机排序时经常会碰到。具体就是使原数组的某个数在打散后的数组中的每个位置上等概率的出现。","tags":["算法"],"title":"洗牌算法"},"rawMarkdownBody":"\n洗牌算法是我们常见的随机问题，在玩游戏、随机排序时经常会碰到。具体就是使原数组的某个数在打散后的数组中的每个位置上等概率的出现。\n\n算法步骤为：\n\n1.  建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值\n2.  生成一个从 0 到 n - 1 的随机数 x\n3.  输出 arr 下标为 x 的数值，即为第一个随机数\n4.  将 arr 的尾元素和下标为 x 的元素互换\n5.  同 2，生成一个从 0 到 n - 2 的随机数 x\n6.  输出 arr 下标为 x 的数值，为第二个随机数\n7.  将 arr 的倒数第二个元素和下标为 x 的元素互换\n\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfunction transformArr(arr) {\n  let len = arr.length\n  let random = Math.floor(Math.random() * len) + 1\n\n  while (len) {\n    let target = arr[random]\n    arr[random] = arr[len - 1]\n    arr[len - 1] = target\n    len--\n  }\n  return arr\n}\n\nconsole.log(transformArr(arr))\n```\n"},{"id":"21c3bf89-af84-5d06-8a83-aa957732e2e3","fields":{"slug":"/sliding-window/"},"excerpt":"算法核心思路 用左右指针维护一个窗口（连续的子数组/子串），根据题目在遍历数组或者字符串的时候动态调整两个指针（一般都是++），遇到可行解就进行记录。 leetcode 算法：求无重复字符的最长子串 给定一个字符串 s…","frontmatter":{"date":"2021-10-22 13:37:40","description":"滑动窗口算法可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。","tags":["算法","leetCode"],"title":"滑动窗口算法"},"rawMarkdownBody":"\n**算法核心思路**\n\n用左右指针维护一个窗口（连续的子数组/子串），根据题目在遍历数组或者字符串的时候动态调整两个指针（一般都是++），遇到可行解就进行记录。\n\n```javascript\nlet left = 0\nlet right = 0\nwhile (right < target.length) {\n  //未满足条件时\n  right++\n  while (condition) {\n    //满足条件时\n    left++ //收缩\n  }\n}\n```\n\n**leetcode 算法：求无重复字符的最长子串**\n\n1. 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n```\n输入: s = \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n2. 完整代码：\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let right = 0\n  let left = 0\n  let targetStr = \"\"\n  while (right !== s.length) {\n    right++\n    let index = s.substring(left, right).indexOf(s[right])\n    if (s.substring(left, right).length > targetStr.length) {\n      targetStr = s.substring(left, right)\n    }\n    if (index !== -1) {\n      left = left + index + 1\n    }\n  }\n  return targetStr.length\n}\n```\n"},{"id":"c1d6d512-6d59-5570-86a9-8c024efab8d0","fields":{"slug":"/http-cache/"},"excerpt":"前端代码打包之后的静态资源要部署在服务器上，这时候就要做对这些静态资源做一些运维配置来做性能优化，其中，gzip 和设置 HTTP 缓存是必不可少的。gzip 可以极大的减少数据传输时的体积，合理的缓存机制则会让浏览器减少对资源的请求。 使用 nginx 开启 gzip…","frontmatter":{"date":"2021-12-06 18:37:40","description":"前端代码打包之后的静态资源要部署在服务器上，这时候就要做对这些静态资源做一些运维配置来做性能优化，其中，gzip 和设置 HTTP 缓存是必不可少的","tags":["HTTP","缓存","Cache-Control"],"title":"HTTP相关的性能优化"},"rawMarkdownBody":"\n前端代码打包之后的静态资源要部署在服务器上，这时候就要做对这些静态资源做一些运维配置来做性能优化，其中，gzip 和设置 HTTP 缓存是必不可少的。gzip 可以极大的减少数据传输时的体积，合理的缓存机制则会让浏览器减少对资源的请求。\n\n## 使用 nginx 开启 gzip\n\nnginx 默认是不开启 gizp 的，在 Linux 系统上打开 _/etc/nginx/nginx.config_ 文件，在 HTTP 部分可以看到如下配置：\n\n```nginx\n# gzip_vary on;\n# gzip_proxied any;\n# gzip_comp_level 6;\n# gzip_buffers 16 8k;\n# gzip_http_version 1.1;\n# gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n```\n\n这些配置默认是被注释的，只需删除#打开注释，再根据需求稍作修改后，重启 nginx 即可。\n\n## HTTP 的强制缓存和协商缓存\n\nHTTP 消息头允许客户端和服务器通过 request 和 response 传递附加信息，利用 Cache-Control 通用消息头字段，通过指定指令来实现缓存机制。\nHTTP 缓存分为强制缓存和协商缓存，一个最重要的区别是强制缓存可以直接复用已缓存的静态资源而无需发出请求。\n简单介绍一下：\n\n- 强制缓存通常使用 Cache-Control 的 max-age 来设置有效时间， 浏览器会在缓存的有效时间内直接复用缓存。\n- 协商缓存是不开启强制缓存时浏览器发送一个携带 Last-Modified 和 Etag 字段的请求来判断缓存资源是否需要重新获取。\n\n这里只大致讲了一下两种 HTTP 缓存的区别以及配置，可见强制缓存有着比协商缓存更快的响应速度，但是却无法感知文件在服务端是否被修改。\n协商缓存还是需要发出请求，通过服务器告诉浏览器是否可以继续使用本地缓存。\n\n## 最终方案\n\n结合当前通常使用 webpack 作为构建单页面的基础工具，可以每次构建时都对打包文件重新命名，让强制缓存也能在文件被修改后由于文件名的变更而失效。\n\n所以通过设置 html 为不缓存，html 引用资源都设置为强制缓存，不过每次构建都会对引用的资源重新 hash 命名，就解决了无法及时得知资源更新的问题。\n\nnginx 配置如下：\n\n```nginx\nserver {\n  location / {\n    add_header Cache-Control no-cache;\n    try_files $uri $uri/ /index.html;\n  }\n\n  location ~* \\.(css|js|png|jpg|jpeg|gif|gz|svg|mp4|ogg|ogv|webm|htc|xml|woff)$ {\n    add_header Cache-Control \"public,max-age=7*24*3600\";\n  }\n}\n\n```\n\n实际效果如下图：\n![截图](./screenshot.png)\n"},{"id":"59f45988-2552-5212-bf6f-a336f6674e5f","fields":{"slug":"/array-reduce/"},"excerpt":"reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 reducer 函数接收4个参数:\nAccumulator (acc) (累计器)\nCurrent Value (cur) (当前值)\nCurrent Index…","frontmatter":{"date":"2022-02-20","description":"reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。","tags":["reduce","算法","面试"],"title":"数组的reduce方法"},"rawMarkdownBody":"\nreduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nreducer 函数接收4个参数:\nAccumulator (acc) (累计器)\nCurrent Value (cur) (当前值)\nCurrent Index (idx) (当前索引)\nSource Array (src) (源数组)\n您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。\n\n以上是MDN上对reduce的部分介绍，最近遇到了几个与之相关的面试题，记录一下。\n\n### 求笛卡尔积\n\n```javascript\nconst input = [\n  ['e1', 'e2'],\n  ['e4', 'e5'],\n  ['e6', 'e7']\n]\nconst calculate = input => {\n  return input.reduce((acc, curr, index) => {\n    if (index === 0) {\n      return acc\n    } else {\n      let arr = []\n      acc.forEach(t => {\n        curr.forEach(item => {\n          arr.push(t + item)\n        })\n      })\n      return arr\n    }\n  })\n}\nconsole.log(calculate(input))\n```\n\n### 把a.b.c.d转换成相应的嵌套对象\n\n```javascript\nlet str = \"a.b.c.d\";\n\nfunction transform() {\n  let arr = str.split(\".\");\n  let obj = {};\n  arr.reduce((prev, current) => {\n    if (typeof prev === \"string\") {\n      obj[prev] = {};\n      obj[prev][current] = {};\n      return obj[prev][current];\n    } else {\n      prev[current] = {};\n      return prev[current];\n    }\n  });\n  return obj;\n}\n\nlet result = transform();\n```\n\n### 请你完成一个safeGet函数，可以安全的获取无限多层次的数据\n\n```javascript\n// 请你完成一个safeGet函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，例如\nvar data = { a: { b: { c: 'yideng' } } }\nsafeGet(data, 'a.b.c') // => yideng\nsafeGet(data, 'a.b.c.d') // => undefined\nsafeGet(data, 'a.b.c.d.e.f.g') // => undefined\n\nconst safeGet = (o,path) => {\n    try {\n        return path.split('.').reduce((o,k) => o[k],o)\n    } catch (error) {\n        return undefined\n    }\n}\n```"},{"id":"febfb3a3-7752-5fe4-9b29-c47723553dc5","fields":{"slug":"/array-sort/"},"excerpt":"冒泡排序 大致流程：依次比较相邻的两个数,正序则不动,倒序则交换位置,如此循环,直到整个数组为有序为止。 快速排序 快速排序就是个二叉树的前序遍历，快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-…","frontmatter":{"date":"2022-03-13","description":"记录两种常见的排序算法。","tags":["算法","快速排序"],"title":"排序算法"},"rawMarkdownBody":"\n### 冒泡排序\n\n大致流程：依次比较相邻的两个数,正序则不动,倒序则交换位置,如此循环,直到整个数组为有序为止。\n\n```javascript\nfunction bubble(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    for (let j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = temp\n      }\n    }\n  }\n\n  return arr\n}\n```\n\n### 快速排序\n\n快速排序就是个二叉树的前序遍历，快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。\n\n```javascript\nfunction quickSort(arr) {\n  if (arr.length <= 1) {\n    return arr\n  }\n  let index = Math.floor(arr.length / 2)\n  let target = arr.splice(index, 1)[0]\n\n  let left = []\n  let right = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < target) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n\n  return quickSort(left).concat([target], quickSort(right))\n}\n```\n"},{"id":"b058c4fc-c891-58d8-a30f-590d6fda1f70","fields":{"slug":"/publish-subscribe/"},"excerpt":"发布订阅 创建一个 EventListener 给 EventListener 添加一个缓存列表，用于存放回调函数以便通知订阅者 发布消息时，EventListener 遍历缓存列表，依次触发回调 故 EventListener 应该有 emit (发布) 、on…","frontmatter":{"date":"2022-03-14","description":"实现一个简易的发布订阅。","tags":["发布订阅","设计模式"],"title":"发布订阅"},"rawMarkdownBody":"\n### 发布订阅\n\n- 创建一个 EventListener\n- 给 EventListener 添加一个缓存列表，用于存放回调函数以便通知订阅者\n- 发布消息时，EventListener 遍历缓存列表，依次触发回调\n- 故 EventListener 应该有 emit (发布) 、on (订阅) 、off (取消订阅) 等方法。\n\n\n```javascript\nclass EventListener {\n  listeners = [];\n\n  on(name, fn) {\n    let listener = {\n      name,\n      fn,\n      isOnce: false,\n    };\n    this.listeners.push(listener);\n    return listener;\n  }\n\n  once(name, fn) {\n    let listener = {\n      name,\n      fn,\n       isOnce: true,\n    };\n    this.listeners.push(listener);\n    return listener;\n  }\n\n  off(listener) {\n    let index = this.listeners.indexOf(listener);\n    if (index !== -1) {\n      this.listeners.splice(index, 1);\n    }\n  }\n\n  emit(name, args) {\n    this.listeners.forEach((listener) => {\n      try {\n        if (listener.name === name) {\n          if (listener.isOnce) {\n            this.off(listener);\n          }\n          listener.fn(args);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n}\n\n```\n\n"}]